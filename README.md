## Описание процесса сдачи лабораторных

### Получение доступа к репозиторию
- Зарегистрироваться на github.com (если аккаунта еще нет)
- Предоставить никнейм аккаунта в:
	- [Таблицу с результатами](https://docs.google.com/spreadsheets/d/1Mf7VQlM3iCh_DLuW3uUuCB_nmAeS6EscR0BsIoZ4sNY)
	- [Группу в ВКонакте](https://vk.com/topic-130670659_46086868)
- После этого дождаться подтверждения того, что вас добавили в команду репозитория
	- Ответом от преподавателя
	- ваш никнейм в общей таблице выделен зеленым
- Принять приглашение к совместной работе над репозиторием (приходит на почту)
### Правила работы с репозиторием
- Вся работа ведется в вашей персональной ветке
	- Ветка должна именоваться `<group>_<FirstName>-<LastName>`
	- Избегайте использования символов `/ , \ . | * +`
	- Не забывайте по завершении работы делать push в удаленную ветку
- По возможности старайтесь сделать красивую историю коммитов в ней
- **ЗАПРЕЩАЕТСЯ ОПРАВЛЯТЬ ИЗМЕНЕНИЯ В ВЕТКУ master**
	- Все ваши коммиты из ветки master будут удалены
	- Кара воспоследует
- Выполняете работу в **исходных файлах с заданиями**, там есть шаблон кода и описание, при этом **НЕ НУЖНО:**
	- Копировать эти файлы в ту же директорию
	- Создавать отдельную директорию для решиний
	- Переименовывать эти файлы
	- Перименовывать и менять сигнатуру методов шаблона кода внутри файла
### Отметки о сдаче задания
- Выполнив задание и отправив его код в свою ветку в репозиторий, отметьте соответствующий чекбокс в [Таблице с результатами](https://docs.google.com/spreadsheets/d/1Mf7VQlM3iCh_DLuW3uUuCB_nmAeS6EscR0BsIoZ4sNY)
- После проверки преподавателем в этой таблице будет отмечено выполнение задание:
	- Зеленый - все хорошо
	- Желтый - принято, но можно лучше
	- Оранжевый - есть замечания, требующие исправления
	- Красный - задание не найдено, задание не выполнено, задание списано
	- Будет добавлен комментарий с замечаниями, после исправления замечаний стоит добавить свой комментарий в трек
### Для всех заданий на Prolog
- Используется [SWI-Prolog](https://www.swi-prolog.org/)
### Задания
#### Prolog - 1
- В данном задании необходимо определить указанные предикаты:
	- ```brother(X,Y)```    -  определяющий являются ли аргументы братьями
	- ```cousin(X,Y)```     -  определяющий являются ли аргументы двоюродными братьями
	- ```grandson(X,Y)```   -  определяющий является ли аргумент Х внуком аргумента Y
	- ```descendent(X,Y)``` -  определяющий является ли аргумент X потомком аргумента Y
- 	Используя следующую структуру взаимоотношений
	- ```father(a,b).```              
	- ```father(a,c).```
	- ```father(b,d).```
	- ```father(b,e).```
	- ```father(c,f). ```
- указать в каком порядке и какие ответы генерируются вашими методами
	- ```?- brother(X,Y).```
	- ```?- cousin(X,Y).```
	- ```?- grandson(X,Y).```
	- ```?- descendent(X,Y).```
#### Prolog - 2
- В данном задании необходимо определить указанные предикаты:
	- ```and(A,B)```
	- ```or(A, B)```
	- ```xor(A, B)```
	- ```not(A)```
	- ```equ(A,B)```
- Затем реализовать предикат для построения таблицы истинности ```truth_table(A,B, expression)```
- Привести выводы таблиц истинности для разных выражений
#### Prolog - 3
- Реализовать предикат ```qsort(L, K)``` - выполняющий сортировку заданном списка ```L``` алгоритмом [Quicksort](https://en.wikipedia.org/wiki/Quicksort)
#### Prolog - 4
- Используя предикат ```qsort(L,K)``` из предыдущего задания разработать предикат:
- ```balanced_tree(L,T)``` - который по заданном списку строит **сбалансированное** бинарное дерево **поиска**
- для построения дерева использовать следующие  нотации:\
	- ```empty``` - пустое дерево 
	- ```instant(R, L, R)``` - бинарное дерево с корнем R и двумя поддеревьями L и R соотвественно (левое и правое)
#### Prolog - 5
- определить предикат ```mrg(L1, L2, R)``` который для двух отсортированных списков ```L1``` и ```L2``` 
- определяет список ```R```, составленный из этих элементов, также являющийся отсортированным
#### Scala  - 1
- В данном задании необходимо реализовать простые функции, используя рекурсию (допускается использование дополнительных "внутренних" функции)
- Функции
	- `def pascal(c: Int, r: Int): Int` - функция возвращающая значение элемента треугольника Паскаля по номеру колонки и строки
  
	![треугольник Паскаля](https://upload.wikimedia.org/wikipedia/commons/7/71/%D0%A2%D1%80%D0%B5%D1%83%D0%B3%D0%BE%D0%BB%D1%8C%D0%BD%D0%B8%D0%BA_%D0%9F%D0%B0%D1%81%D0%BA%D0%B0%D0%BB%D1%8F.png)
	- ` def balance(chars: List[Char]): Boolean` - функция, подсчитывающая баланс скобок в выражении (по открытым и закрытым скобкам)
	- `def countChange(money: Int, coins: List[Int])` - функция, определяющая количество возможных вариантов размена суммы (`money`) монетами номиналом (`coins`)
#### Scala  - 2
- В это задании необходимо реализовать множество целых числе заданное как функцию `type Set = Int => Boolean`, данная функция отвечает на вопрос "содержится ли заданный элемент в множестве", выделяя его таким образом из множества целых чисел
- Для выполнения задания необходимо представить свою реализацию функций, тело которых представлено как `???`
- После выполнения задания, подумайте над тем, где все-таки хранятся элементы множества
#### Scala  - 3
- Анаграмма слова - это перестановка его букв так, что образуется слово с другим значением. Например, если мы переставляем буквы слова `Elvis`, мы можем получить слово `lives`, которое является одной из его анаграмм.
- Анаграмма предложения - это перестановка всех символов в предложении так, что формируется новое предложение. Новое предложение состоит из значащих слов, количество которых может соответствовать или не соответствовать количеству слов в исходном предложении. Например, предложение: `I love you` - это анаграмма предложения `you olive` 
- При создании анаграмм мы будем игнорировать регистр символов и знаки препинания.
- Ваша конечная цель состоит в том, чтобы реализовать функцию, который, учитывая список слов, представляющих предложение, находит все анаграммы этого предложения. - Обратите внимание, что мы использовали термин «значимый» для определения анаграмм. Вам будет предоставлен словарь, то есть список слов, обозначающих слова, которые имеют значение.
- Общая идея:
	- Преобразовать символы предложения в список, содержащий пары - (символ, частота его появления в предложении)
	- Чтобы найти анаграммы слова, нужно найти слова из словаря, которые имеют одинаковый список вхождений. 
	- Чтобы найти анаграмму предложения необходимо извлечь из него любое подмножество символов, и попытаться сформировать какие-либо значимые слова. Из оставшихся символов мы решим задачу рекурсивно, а затем объединим все значимые слова, которые мы нашли, с рекурсивным решением.
#### Haskell
- Необходимо реализовать вычисление расстояния Хемминга для двух ДНК.
- [Исходное описание задачи](http://rosalind.info/problems/hamm/)
- Для запуска базовых тестов (рекомендуется дополнять своими) `stack test`
 - Для использования интерактивной среды `stack ghci`
- [Установка и настройка Haskell](https://www.haskell.org/downloads)

